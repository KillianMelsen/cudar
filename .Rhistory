16*100
16*200
16*300
p
p <- 4800
library(rCUDA)
getDeviceProperties()
set.seed(1997)
p <- 4800
A <- matrix(rnorm(p^2), p)
B <- matrix(rnorm(p^2), p)
system.time(CPU <- A %*% B)
system.time(DIY32 <- rCUDA::matMul(A, B, "FP32"))
system.time(DIY64 <- rCUDA::matMul(A, B, "FP64"))
system.time(gemm32 <- rCUDA::cudaGemm(A, B, "FP32"))
system.time(gemm64 <- rCUDA::cudaGemm(A, B, "FP64"))
system.time(gemm32 <- rCUDA::cudaGemm(A, B, "FP32"))
system.time(gemm64 <- rCUDA::cudaGemm(A, B, "FP64"))
system.time(gemm32 <- rCUDA::cudaGemm(A, B, "FP32"))
system.time(gemm64 <- rCUDA::cudaGemm(A, B, "FP64"))
system.time(gemm32 <- rCUDA::cudaGemm(A, B, "FP32"))
system.time(gemm32 <- rCUDA::cudaGemm(A, B, "FP32"))
system.time(gemm64 <- rCUDA::cudaGemm(A, B, "FP64"))
system.time(gemm64 <- rCUDA::cudaGemm(A, B, "FP64"))
system.time(gemm32 <- rCUDA::cudaGemm(A, B, "FP32"))
# Functions:
NAIVE <- function(P, L) {
return(solve(P + L %*% t(L)))
}
WMI1 <- function(P, L) {
Pi <- diag(1 / diag(P))
PiL <- Pi %*% L
inv <- solve(diag(ncol(L)) + t(L) %*% PiL)
return(Pi - PiL %*% inv %*% t(PiL))
}
WMI2 <- function(Pvec, L) {
p <- nrow(L)
Pi <- 1 / Pvec
PiL <- Pi * L
inv <- solve(diag(ncol(L)) + t(L) %*% PiL)
negB <- PiL %*% -inv %*% t(PiL)
diag.new <- diag(negB) + Pi
negB[seq(1, length(negB), p + 1)] <- diag.new
return(negB)
}
# Scaling:
size <- c(50, 200, 500, 1000, 2000, 3000, 4000, 8000, 16000, 32000)
WMI1.t <- WMI2.t <- numeric(length(size))
NAIVE.t <- numeric(length(size[which(size <= 4000)]))
names(WMI1.t) <- names(WMI2.t) <- size
names(NAIVE.t) <- size[which(size <= 4000)]
p=32000
set.seed(1997)
Pvec <- diag(P)
set.seed(1997)
Pvec <- runif(p, 0.1, 0.3)
L <- matrix(rnorm(p * 5), p)
result2 <- median(microbenchmark(WMI2(Pvec, L), times = 10, unit = "ms")$time) / 1e6 # from ns to ms
library(microbenchmark)
result2 <- median(microbenchmark(WMI2(Pvec, L), times = 10, unit = "ms")$time) / 1e6 # from ns to ms
gc()
WMI2 <- function(Pvec, L) {
p <- nrow(L)
Pi <- 1 / Pvec
PiL <- Pi * L
inv <- solve(diag(ncol(L)) + t(L) %*% PiL)
negB <- PiL %*% -inv %*% t(PiL)
diag.new <- diag(negB) + Pi
negB[seq(1, length(negB), p + 1)] <- diag.new
return(negB)
}
# Trying stuff:
load("repositories/gfBLUP_2024/genotypes/K_hyper.RData")
K <- K[1:3, 1:3]
EDK <- eigen(K)
U <- EDK$vectors
D <- diag(EDK$values)
p = 5
set.seed(1997)
Pg <- diag(runif(p, 0.1, 0.3))
Pe <- diag(runif(p, 0.1, 0.3))
Pgvec <- diag(Pg)
Pevec <- diag(Pe)
Lg <- matrix(rnorm(p * 2), p)
Le <- matrix(rnorm(p * 2), p)
# Naive
V.naive <- solve(kronecker(D, (Pg + Lg %*% t(Lg))) + kronecker(diag(3), (Pe + Le %*% t(Le))))
V.naive
# WMI_2
d1 <- D[1,1]
K
K[,]
EDK$vectors %*% diag(EDK$values) %*% EDK$vectors
EDK$vectors %*% diag(EDK$values) %*% t(EDK$vectors)
K
EDK$vectors * EDK$values %*% t(EDK$vectors)
(EDK$vectors * EDK$values) %*% t(EDK$vectors)
EDK$values * EDK$vectors
EDK$values * EDK$vectors %*% t(EDK$vectors)
(EDK$values * EDK$vectors) %*% t(EDK$vectors)
K
A <- matrix(rnorm(2^2),2)
A
B <- diag(c(1,2))
B
A %*% B
A * B
B * A
diag(B) * A
A %*% B
A * diag(B)
A * t(diag(B))
diag(B)
t(diag(B))
B %*% A
diag(B) * A
matrix(diag(B)) * A
matrix(diag(B))
t(matrix(diag(B))) * A
B %*% A
diag(B) * A
A %*% B
A * diag(B)
t(A) * diag(B)
B %*% A
diag(B) * A
A %*% B
diag(B) * t(A)
t(A) * diag(B)
A * diag(B)
A
B
A %*% B
B %*% A
B
A
B %*% A
B
A
diag(B) * A
A
B
A %*% B
t(t(A) * diag(B))
K
EDK$vectors %*% EDK$values * EDK$vectors
EDK$vectors %*% (EDK$values * EDK$vectors)
EDK$vectors %*% diag(EDK$values) %*% t(EDK$vectors)
EDK$vectors %*% (EDK$values * t(EDK$vectors))
EDK$vectors %*% EDK$values * t(EDK$vectors)
t(t(EDK$vectors) * EDK$values) %*% t(EDK$vectors)
# Naive
V.naive <- solve(kronecker(D, (Pg + Lg %*% t(Lg))) + kronecker(diag(3), (Pe + Le %*% t(Le))))
V.naive
# WMI_2
d1 <- D[1,1]
L <- sqrt(d1) * Lg + Le
Pvec <- d1 * Pgvec + Pevec
V1 <- WMI2(Pvec, L)
V1
sqrt(0)
sqrt(1-0.5)
sqrt(1-0.5)
sqrt(0.6)
sqrt(1-0.6)
sqrt(0.6) * sqrt(0.6)
H <- matrix(c(sqrt(0.6), 0,
0, sqrt(0.7)),
2)
H
library(clusterGeneration)
H
H
Sp <- cov2cor(clusterGeneration::genPositiveDefMat(2, "eigen")$Sigma)
Sp
H %*% Sp %*% H
Sg <- H %*% Sp %*% H
Sg
Se <- Sp - Sg
Se
sqrt(0.4)
E <- matrix(c(sqrt(0.4), 0,
0, sqrt(0.4)),
2)
E
Sg
H %*% Sp %*% H
Se
E %*% Sp %*% E
H %*% Sp %*% H + E %*% Sp %*% E
Sp
E <- matrix(c(sqrt(0.4), 0,
0, sqrt(0.3)),
2)
H %*% Sp %*% H + E %*% Sp %*% E
Sp
H
E
H^2
E^2
sqrt(9+9)
H
sqrt(diag(2) - H^2)
E
A <- diag(c(1,2))
A
B <- diag(c(3,4))
A
B
X <- Sp
X
A %*% X %*% A + B %*% X %*% B
(A + B) %*% X %*% (A + B)
(A + B) %*% X
A %*% X + B %*% X
outer(diag(A), diag(A))
outer(diag(A), diag(A)) * X
A %*% X %*% A
dA <- diag(A)
dB <- diag(B)
outer(dA, dA) * X + outer(dB, dB) * X
A %*% X %*% A + B %*% X %*% B
(outer(dA, dA) + outer(dB, dB)) * X
outer(dA,dA)
matrix(dA)
matrix(dA) %*% t(matrix(dA))
matrix(dA) %*% t(matrix(dA)) * A
(matrix(dA) %*% t(matrix(dA))) * A
outer(dA,dA) * X
(matrix(dA) %*% t(matrix(dA))) * X
h <- matrix(0.6, 0.7)
h <- matrix(c(sqrt(0.6), sqrt(0.7)))
h
h^2
h
e <- sqrt(matrix(c(1,1)) - h^2)
e
e^2
h^2 + e^2
A
X
outer(h,h)
h %*% t(h)
e %*% t(e)
h %*% t(h) + e %*% t(e)
sqrt(0.91)
sqrt(0.9)
0.5^2
sqrt(0.25)
sqrt(0.75)
sqrt(0.25)
0.5^2
0.6^2
sin(0.25)
?sin
asin(0.25)
sin(asin(0.25))
h
hsin <- asin(h)
hsin
sin(hsin)
h
H^2
h^2
e^2
hsin
hsin^2
outer(h,h) + outer(e,e)
cos(h[1]-h[2])
cos(hsin[1]-hsin[2])
sqrt(2)/2
sqrt(2)/2*sqrt(2)/2
pi
pi/2
pi/4
theta = 0.5
cos(theta)
cos(theta)^2
cos(theta)^2+sin(theta)^2
theta <- c(0.5, 0.6)
h <- cos(theta)
h
e <- sin(theta)
e
outer(h,h)
outer(e,e)
outer(h,h) + outer(e,e)
theta <- c(0.9, 0.1)
h <- cos(theta)
e <- sin(theta)
outer(h,h) + outer(e,e)
d1 <- 1.1
# Function to quickly calculate the inverse of d * Sg given the loadings and uniquenesses,
# and where d is one of the eigenvalues of the kinship matrix:
inv.SG <- function(d = 1, Pvec, Lg) {
p <- nrow(Lg)
iP <- 1 / (Pvec * d)
iPLg <- iP * Lg * sqrt(d)
inv <- solve(diag(ncol(Lg)) + (sqrt(d) * t(Lg)) %*% iPLg)
negB <- iPLg %*% -inv %*% t(iPLg)
diag.new <- diag(negB) + iP
negB[seq(1, length(negB), p + 1)] <- diag.new
return(negB)
}
# Function to compute the approximate inverse of V given the
# genetic loadings/uniquenesses and the residual loadings:
inv.V <- function(d = 1, Pvec, Lg, Le) {
iSg <- inv.SG(d, Pvec, Lg)
iSgLe <- iSg %*% Le
inv <- solve(diag(ncol(Le)) + t(Le) %*% iSgLe)
negB <- iSgLe %*% -inv %*% t(iSgLe)
return(negB + iSg)
}
# Scaling:
library(microbenchmark)
# size <- c(50, 100, 200, 400, 800, 1600, 3200, 6400, 12800, 25600)
size <- c(50, 100, 200, 400, 800, 1600, 3200, 6400, 12800, 25600)
slow <- fast <- numeric(length(size))
names(slow) <- names(fast) <- size
for (p in size) {
set.seed(1997)
Pvec <- runif(p, 0.2, 0.4)
P <- diag(Pvec)
Lg <- matrix(rnorm(p * 5), p)
Le <- matrix(rnorm(p * 5), p)
if (p <= 3200) {
result.slow <- median(microbenchmark(solve(d1 * (Lg %*% t(Lg) + P) + (Le %*% t(Le))), times = 40, unit = "ms")$time) / 1e6 # from ns to ms
gc()
} else {
result.slow <- NA
}
result.fast <- median(microbenchmark(inv.V(d1, Pvec, Lg, Le), times = 40, unit = "ms")$time) / 1e6 # from ns to ms
gc()
slow[as.character(p)] <- result.slow
fast[as.character(p)] <- result.fast
}
library(ggplot2)
data <- data.frame(slow = slow,
fast = fast,
p = size)
data <- tidyr::pivot_longer(data, 1:2, names_to = "Method", values_to = "Time")
save(data, file = "timing2.rds")
ggplot(data, aes(x = p, y = Time, colour = Method)) +
geom_line() +
ylab("Time (ms)")
slow
p=3200
set.seed(1997)
Pvec <- runif(p, 0.2, 0.4)
P <- diag(Pvec)
Lg <- matrix(rnorm(p * 5), p)
Le <- matrix(rnorm(p * 5), p)
gc()
all.equal(solve(d1 * (Lg %*% t(Lg) + P) + (Le %*% t(Le))), inv.V(d1, Pvec, Lg, Le))
fast
2.571961e+03
600*2.5
600*2.5*10
20000/3600
format(object.size(matrix(1.2,21000,21000)), units = "GB")
format(object.size(matrix(1.2,21000,21000)), units = "GB")*600
format(object.size(matrix(1.2,21000,21000))*600, units = "GB")
install.packages("keras")
reticulate::install_miniconda()
keras::install_keras(method = "conda", python_version = "3.10")
setwd("C:/Users/Killian/Desktop")
d <- read.csv("RH_data.csv")
View(d)
d <- read.csv("RH_data.csv")
d$Time <- as.factor(d$Time)
d$Concentration <- as.factor(d$Concentration)
?anova
View(d)
fit <- lm(Viability ~ Time + Concentration, data = d)
summary(fit)
anova(fit)
library(emmeans)
emmeans(fit)
?emmeans
emmeans(fit, ~ Time)
emmeans(fit, ~ Time + Concentration)
agricolae::LSD.test(fit, ~ Time)
agricolae::LSD.test(fit, Time)
?agricolae::LSD.test
agricolae::LSD.test(fit, "Time")
fit <- aov(Viability ~ Time + Concentration, data = d)
fit
summary(fit)
anova(fit)
agricolae::LSD.test(fit, "Time")
x <- agricolae::LSD.test(fit, "Time")
x
plot(x)
fit <- lm(Viability ~ Time, data = d)
fit
summar(lm)
summary(fit)
aov(fit)
anova(fit)
1.71^2
fit <- lm(Viability ~ Concentration, data = d)
summary(fit)
anova(fit)
fit <- lm(Viability ~ Time * Concentration, data = d)
summary(fit)
anova(fit)
?glm
fit <- glm(Viability ~ Time * Concentration, binomial, data = d)
d$Viability <- d$Viability / 100
View(d)
fit <- glm(Viability ~ Time * Concentration, binomial, data = d)
d$Dead <- 1 - d$Viability
View(d)
fit <- glm(c(Viability, Dead) ~ Time * Concentration, binomial, data = d)
d <- read.csv("RH_data.csv")
d$Time <- as.factor(d$Time)
d$Concentration <- as.factor(d$Concentration)
d$Viability <- d$Viability / 100
d$Dead <- 1 - d$Viability
fit <- lm(Viability ~ Time * Concentration, data = d)
summary(fit)
anova(fit)
dose <-c(0.375,0.75,1.5,3,6,12,24)
ndead<-c(0,1,8,11,16,18,20)
nins <-c(20,20,20,20,20,20,20)
datalarvae <-data.frame(dose,ndead,nins,row.names=NULL)
print(datalarvae, row.names=FALSE)
#explanatory variable x is the (natuaral) logarithm of the dose
x<-log(dose)
# empirical logits are calculated
emplogit <-log((ndead+0.5)/(nins-ndead+0.5))
# also calculate observed proportions dead per group
proportion <- ndead/nins
# plot proportions versus dose
plot(dose,proportion)
# plot proportions versus x
plot(x,proportion)
d <- read.csv("RH_data.csv")
d$Time <- as.factor(d$Time)
d$Concentration <- as.factor(d$Concentration)
d$Viability <- d$Viability / 100
fit <- lm(Viability ~ Time * Concentration, data = d)
summary(fit)
anova(fit)
62.764^2
x <- agricolae::HSD.test(fit)
x <- emmeans(fit, ~ Time * Concentration)
x
plot(x)
?agricolae::HSD.test
install.packages("rstatix")
?rstatix::tukey_hsd(
)
?rstatix::tukey_hsd
rstatix::tukey_hsd(fit)
fit <- aov(Viability ~ Time * Concentration, data = d)
rstatix::tukey_hsd(fit)
fit <- lm(Viability ~ Time * Concentration, data = d)
rstatix::tukey_hsd(fit)
agricolae::HSD.test(fit, "Concentration")
x <- agricolae::HSD.test(fit, "Concentration")
x
?TukeyHSD
TukeyHSD(fit)
fit <- aov(Viability ~ Time * Concentration, data = d)
TukeyHSD(fit)
summary(fit)
anova(fit)
fit
fit.aov <- aov(Viability ~ Time * Concentration, data = d)
fit.lm <- lm(Viability ~ Time * Concentration, data = d)
summary(fit)
m
summary(fit.lm)
summary(fit.aov)
TukeyHSD(fit.aov)
TukeyHSD(fit.aov)$Concentration
TukeyHSD(fit.aov, "Concentration")
d <- read.csv("RH_data.csv")
d$Time <- as.factor(d$Time)
d$Concentration <- as.factor(d$Concentration)
d$Viability <- d$Viability / 100
fit.aov <- aov(Viability ~ Time * Concentration, data = d)
fit.lm <- lm(Viability ~ Time * Concentration, data = d)
summary(fit.lm)
summary(fit.aov)
TukeyHSD(fit.aov, "Concentration")
View(d)
d <- read.csv("RH_data.csv")
d$Time <- as.factor(d$Time)
d$Concentration <- as.factor(d$Concentration)
d <- read.csv("RH_data.csv")
d$Time <- as.factor(d$Time)
d$Viability <- d$Viability / 100
fit.aov <- aov(Viability ~ Time * Concentration, data = d)
fit.lm <- lm(Viability ~ Time * Concentration, data = d)
summary(fit.lm)
summary(fit.aov)
setwd("C:/Users/Killian/Desktop/cudar")
devtools::checl()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
